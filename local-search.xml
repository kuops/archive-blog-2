<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>graph-easy 快速入门</title>
    <link href="/2020/04/30/graph-easy-quick-start/"/>
    <url>/2020/04/30/graph-easy-quick-start/</url>
    
    <content type="html"><![CDATA[<!-- markdownlint-disable MD013 --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一款命令行绘图工具</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="bash">brew install cpanminusbrew install graphvizcpanm --mirror http://mirrors.163.com/cpan --mirror-only Graph::Easyln -s /usr/local/Cellar/perl/5.30.2_1/bin/graph-easy /usr/local/bin/graph-easy</code></pre><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>基本用法</p><pre><code class="bash">echo &quot;[step1] --&gt; [step2]&quot; |graph-easy</code></pre><p>输出结果</p><pre><code class="bash">+-------+     +-------+| step1 | --&gt; | step2 |+-------+     +-------+</code></pre><p>多个分支</p><pre><code class="bash">echo &quot;[step1] --&gt; [step2-1],[step2-2],[step2-3]&quot; |graph-easy</code></pre><p>输出结果</p><pre><code class="bash">+---------+     +---------+     +---------+| step2-3 | &lt;-- |  step1  | --&gt; | step2-1 |+---------+     +---------+     +---------+                  |                  |                  v                +---------+                | step2-2 |                +---------+</code></pre><p>带注释的用法</p><pre><code class="bash">echo &quot;[step1] -- comment --&gt; [step2] -- comment --&gt; [step3]&quot; |graph-easy</code></pre><p>输出结果:</p><pre><code class="bash">+-------+  comment   +-------+  comment   +-------+| step1 | ---------&gt; | step2 | ---------&gt; | step3 |+-------+            +-------+            +-------+</code></pre><p>稍微复杂的可以以文件方式输出</p><pre><code class="bash"># cat a.txt[kube-node] -- request --&gt; [127.0.0.1:8443][127.0.0.1:8443] -- upstream --&gt; [kube-master1:6443]{origin: 127.0.0.1:8443; offset: 2,0}[127.0.0.1:8443] -- upstream --&gt; [kube-master2:6443]{origin: 127.0.0.1:8443; offset: 2,-2}[127.0.0.1:8443] -- upstream --&gt; [kube-master3:6443]{origin: 127.0.0.1:8443; offset: 2,2}graph-easy a.txt</code></pre><p>输出结果:</p><pre><code class="bash">                                            upstream    +-------------------+                           +--------------------------&gt; | kube-master2:6443 |                           |                            +-------------------+                           |                           |                           |+-----------+  request   +----------------+  upstream   +-------------------+| kube-node | ---------&gt; | 127.0.0.1:8443 | ----------&gt; | kube-master1:6443 |+-----------+            +----------------+             +-------------------+                           |                           |                           |                           |                upstream    +-------------------+                           +--------------------------&gt; | kube-master3:6443 |                                                        +-------------------+</code></pre><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>参考 graph-easy-cn</p><pre><code class="bash">https://weishu.gitbooks.io/graph-easy-cn/content/index.html</code></pre>]]></content>
    
    
    <categories>
      
      <category>terminal-tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graph-easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 efk 对 kubernetes 日志进程聚合</title>
    <link href="/2020/03/31/kubernetes-logging-aggeration-using-efk/"/>
    <url>/2020/03/31/kubernetes-logging-aggeration-using-efk/</url>
    
    <content type="html"><![CDATA[<h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><p>在 kubernetes 中，日志大概可以分为三类:</p><h3 id="docker-标准输出"><a href="#docker-标准输出" class="headerlink" title="docker 标准输出"></a>docker 标准输出</h3><p>在 docker 的 <code>/var/lib/docker/containers/xxxx-json.log</code>，在 kubernets 中，<code>/var/log/containers/</code> 使用 <code>readlink</code> 指向 <code>/var/log/pods/&lt;namespace&gt;-&lt;podname&gt;/&lt;containers&gt;/x.log</code>，而 <code>/var/log/pods/</code> 又指向了 docker 的 json.log, 因为这种日志输出不构标准，每个程序的日志规范不太一样，对该日志只进行按行搜索，不进行分词操作。</p><h3 id="程序的规范日志"><a href="#程序的规范日志" class="headerlink" title="程序的规范日志"></a>程序的规范日志</h3><p>这一类日志一般跟开发约定好规范,使用同一目录进行存放，如容器中的 <code>/data/logs/appname/*.log</code>, 而 <code>/data/logs</code> 可以作为 pod 的 volume 进行挂载, 因为该日志是一种标准规范，可以进行分词操作。</p><h3 id="ingress-访问日志"><a href="#ingress-访问日志" class="headerlink" title="ingress 访问日志"></a>ingress 访问日志</h3><p>这一类日志，用来定位请求，一般用来做故障分析，包括域名，状态码，响应时间等信息。</p><h2 id="日志搜集实践"><a href="#日志搜集实践" class="headerlink" title="日志搜集实践"></a>日志搜集实践</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><ol><li>准备 kubernets 集群,并安装好网络插件。</li></ol><pre><code class="bash"># 步骤略kubeadm init </code></pre><ol start="2"><li>准备 persistent volume ，这里为了方便使用 rancher 的 local-path-provisioner，默认的路径为 <code>/opt/local-path-provisioner</code></li></ol><pre><code class="bash">kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/master/deploy/local-path-storage.yaml</code></pre><ol start="3"><li>安装 istio ingress</li></ol><pre><code class="bash">istioctl manifest apply  --set values.global.proxy.accessLogFile=&quot;/dev/stdout&quot; --set values.mixer.telemetry.enabled=false --set values.prometheus.enabled=false</code></pre><ol start="3"><li>部署示例应用,使用镜像 <code>kuops/log-example-app</code>,程序会同时往 <code>/data/log/log-app/info.log</code>和标准输出来输出日志, <a href="https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/main.go" target="_blank" rel="noopener">程序源码</a>,</li></ol><pre><code class="bash">kubectl apply -f https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/log-app.yaml</code></pre><h3 id="部署-efk"><a href="#部署-efk" class="headerlink" title="部署 efk"></a>部署 efk</h3><p>首先对 yaml 进行修改: </p><pre><code class="bash"># 下载 yamlcurl -LO https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/elasticsearch.yamlcurl -LO https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/filebeat.yamlcurl -LO https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/kibana.yaml############################## elasticsearch.yaml 可以修改 ############################## service kind 里的 spec.ports.nodeport...  ports:  - name: http    port: 9200    # nodeport ，固定为 31001    nodePort: 31001    protocol: TCP  type: NodePort############################ filbeat.yaml 修改以下地方############################ daemonset kind 里的 spec.template.spec 中的 containers.volumeMounts 和 volumes...          volumeMounts:      ...      # 这里，如果没有单独为 docker 使用磁盘，修改为 `/var/lib/docker/containers`          - name: varlibdockercontainers            mountPath: /data/docker/containers            readOnly: true      ...      # 这里, 是标准输出日志的 path , 路径是 rancher local volume 的 configmap 中的路径          - name: filelog            mountPath: /opt/local-path-provisioner            readOnly: true    ...        volumes:    # 这里，如果没有单独为 docker 使用磁盘，修改为 `/var/lib/docker/containers`        - name: varlibdockercontainers          hostPath:            path: /data/docker/containers    ...    # 这里, 是标准输出日志的 path , 路径是 rancher local volume 的 configmap 中的路径        - name: filelog          hostPath:            path: /opt/local-path-provisioner############################ kibana.yaml 修改以下地方############################ service kind 里的 spec.ports.nodeport...  ports:    - port: 5601      nodePort: 31002      protocol: TCP      name: http      targetPort: 5601  selector:    k8s-app: kibana  type: NodePort</code></pre><p>部署 elasticsearch, filebeat, kibana;</p><pre><code>kubectl apply -f elasticsearch.yamlkubectl apply -f filebeat.yamlkubectl apply -f kibana.yaml</code></pre><p>修改 istio 的 ingressgateway</p><pre><code># 使用 kubectl edit 修改 添加 hostPort kubectl edit -n istio-system  deployments.apps istio-ingressgateway...        ports:        - containerPort: 15020          protocol: TCP        - containerPort: 80          protocol: TCP      # 添加 hostPort          hostPort: 80</code></pre><p>添加 virtualservice</p><pre><code class="bash">curl -LO https://raw.githubusercontent.com/kuops/kuops.github.io/master/files/kubernetes-logging-aggeration-using-efk/kibana-vs.yaml# 修改 INGRESS_NODE_IP 为 ingressgateway 所在 node 的 IP, 例如 `kibana.10.7.0.101.nip.io`...hosts:  - &quot;kibana.INGRESS_NODE_IP.nip.io&quot;</code></pre><p>在 kibana 中, 使用 devtools 为 es 中添加 ingress Pipeline</p><pre><code class="bash">PUT _ingest/pipeline/ingress{    &quot;description&quot;: &quot;ingress&quot;,    &quot;on_failure&quot;: [      {        &quot;set&quot;: {          &quot;field&quot;: &quot;_index&quot;,          &quot;value&quot;: &quot;failed-{{ _index }}&quot;        }      }    ],    &quot;processors&quot;: [      {        &quot;grok&quot;: {          &quot;field&quot;: &quot;message&quot;,          &quot;patterns&quot;: [            &quot;&quot;&quot;\[%{TIMESTAMP_ISO8601:timestamp}\] &quot;%{DATA:method} (?:%{URIPATH:uri_path}(?:%{URIPARAM:uri_param})?|%{DATA:})%{DATA:protocol}&quot; %{NUMBER:status_code:int} %{DATA:response_flags} %{NUMBER:bytes_sent:int} %{NUMBER:bytes_received:int} %{NUMBER:duration:int} (%{NUMBER:upstream_service_time}|-) &quot;%{IPORHOST:remote_ip}(?:,\s)?%{DATA:forwarded_for}&quot; &quot;%{DATA:user_agent}&quot; &quot;%{DATA:request_id}&quot; &quot;%{DATA:authority}&quot; %{DATA:upstream_service}&quot;&quot;&quot;          ]        }      },      {        &quot;gsub&quot;: {          &quot;field&quot;: &quot;uri_path&quot;,          &quot;pattern&quot;: &quot;HTTP/1.1&quot;,          &quot;replacement&quot;: &quot;&quot;        }      },      {        &quot;gsub&quot;: {          &quot;field&quot;: &quot;uri_path&quot;,          &quot;pattern&quot;: &quot;HTTP/2&quot;,          &quot;replacement&quot;: &quot;&quot;        }      },      {        &quot;remove&quot;: {          &quot;field&quot;: &quot;message&quot;        }      }    ]}</code></pre><p>在 es 中添加程序规范日志的 pipeline</p><pre><code class="bash">PUT _ingest/pipeline/podfile{      &quot;description&quot;: &quot;podfile&quot;,      &quot;processors&quot;: [        {          &quot;grok&quot;: {            &quot;field&quot;: &quot;message&quot;,            &quot;patterns&quot;: [              &quot;&quot;&quot;%{TIMESTAMP_ISO8601:log_time} \[%{LOGLEVEL:log_level}\] %{GREEDYDATA:log_msg}&quot;&quot;&quot;            ]          }        },        {          &quot;remove&quot;: {            &quot;field&quot;: &quot;message&quot;          }        }      ],      &quot;on_failure&quot;: [        {          &quot;set&quot;: {            &quot;field&quot;: &quot;_index&quot;,            &quot;value&quot;: &quot;failed-{{ _index }}&quot;          }        }      ]  }</code></pre><p>查看程序规范输出日志</p><p><img src="/images/kubernetes-logging-aggeration-using-efk/efk_podfile.jpg" srcset="/img/loading.gif" alt=""></p><p>查看 ingress 日志</p><p><img src="/images/kubernetes-logging-aggeration-using-efk/efk_ingress.jpg" srcset="/img/loading.gif" alt=""></p><p>查看标准输出</p><p><img src="/images/kubernetes-logging-aggeration-using-efk/efk_stdout.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>logging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fzf 快速入门</title>
    <link href="/2020/03/24/fzf-quick-start/"/>
    <url>/2020/03/24/fzf-quick-start/</url>
    
    <content type="html"><![CDATA[<!-- markdownlint-disable MD013 --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>fzf 是 go 语言写的一款命令行模糊查找器。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用 vim + fzf 快速查找当前目录下文件并打开</p><pre><code class="bash">vim $(fzf)</code></pre><p>使用方向键或者 <code>C-j</code>, <code>C-k</code> 或者 <code>C-n</code>, <code>C-p</code>选择项目,回车键确认项目</p><p>安装完毕之后, 默认绑定的快捷键:</p><ul><li><p><code>C-t</code> 粘贴选择的目录或者文件到命令行</p></li><li><p><code>C-r</code> 打开历史命令记录，选择后粘贴到命令行</p></li><li><p><code>ALT-c</code> 进入选择的目录, 如果使用的是 iterm2 需要单独设定 <code>options</code> 按键为 <code>Esc+</code></p></li></ul><p><img src="/images/fzf_quick_start/fzf_iterm2_profiles_setting.png" srcset="/img/loading.gif" alt="iterm2_settings"></p><h2 id="模糊补全"><a href="#模糊补全" class="headerlink" title="模糊补全"></a>模糊补全</h2><p>补全文件和目录:</p><ul><li><code>COMMAND [DIRECTORY/][FUZZY_PATTERN]**&lt;TAB&gt;</code></li></ul><pre><code class="bash"># Files under current directory# - You can select multiple items with TAB keyvim **&lt;TAB&gt;# Files under parent directoryvim ../**&lt;TAB&gt;# Files under parent directory that match `fzf`vim ../fzf**&lt;TAB&gt;# Files under your home directoryvim ~/**&lt;TAB&gt;# Directories under current directory (single-selection)cd **&lt;TAB&gt;# Directories under ~/github that match `fzf`cd ~/github/fzf**&lt;TAB&gt;</code></pre><p>补全进程 id</p><pre><code class="bash"># Can select multiple processes with &lt;TAB&gt; or &lt;Shift-TAB&gt; keyskill -9 &lt;TAB&gt;</code></pre><p>补全 ssh 主机名(<code>~/.ssh/config</code>), 或者 telnet (<code>/etc/hosts</code>):</p><pre><code class="bash">ssh **&lt;TAB&gt;telnet **&lt;TAB&gt;</code></pre><p>补全环境变量, 和别名</p><pre><code class="bash">unset **&lt;TAB&gt;export **&lt;TAB&gt;unalias **&lt;TAB&gt;</code></pre><p>设置 preview, 需要安装 <code>bat</code> 命令如果没有,可以用 <code>cat</code> 或者 <code>head</code> 代替, 添加到 <code>~/.zshrc</code></p><pre><code class="bash">FZF_DEFAULT_OPTS=FZF_DEFAULT_OPTS+=&quot; --preview-window &#39;right:60%&#39;&quot;FZF_DEFAULT_OPTS+=&quot; --bind alt-k:preview-up,alt-k:preview-up,alt-j:preview-down,alt-n:preview-down&quot;FZF_DEFAULT_OPTS+=&quot; --preview &#39;bat --color=always --italic-text=always --style=numbers,changes,header --line-range :300 {} &#39;&quot;export FZF_DEFAULT_OPTS</code></pre><p>设置跟踪软连, 排除 git 目录</p><pre><code class="bash">export FZF_DEFAULT_COMMAND=&#39;fd --type f --hidden --follow --exclude .git&#39;</code></pre><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>安装以下两个插件:</p><pre><code class="bash">Plug &#39;/usr/local/opt/fzf&#39;Plug &#39;junegunn/fzf.vim&#39;</code></pre><p>常用命令</p><ul><li><code>:Files</code> 查看当前目录的文件</li><li><code>:Buffers</code> 切换缓冲区</li></ul>]]></content>
    
    
    <categories>
      
      <category>terminal-tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fzf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux 快速入门</title>
    <link href="/2020/03/22/tmux-quick-start/"/>
    <url>/2020/03/22/tmux-quick-start/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tmux 的作者将其描述为终端多路复用器 (terminal multiplexer)。使用 tmux 的好处主要有两点:</p><a id="more"></a><ul><li>多窗口操作，在一个终端分出多个面板</li><li>避免 SSH 连接不稳定，断开前台任务问题</li></ul><p>tmux 所有命令都以前置按键方式进行触发（默认为 <code>C-b</code>），<code>C-b</code> 表示按住 <code>ctrl</code> 键和 ``b` 键:</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>常用命令:</p><table><thead><tr><th align="left">描述</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">启动新的会话</td><td align="left">终端输入 <code>tmux</code></td></tr><tr><td align="left">创建新的会话并指定名称</td><td align="left">终端输入 <code>tmux new -s name</code></td></tr><tr><td align="left">查看会话列表</td><td align="left">终端输入 <code>tmux ls</code></td></tr><tr><td align="left">重新连接会话</td><td align="left">终端输入 <code>tmux a</code></td></tr><tr><td align="left">指定会话连接</td><td align="left">终端输入 <code>tmux a -t num/name</code></td></tr><tr><td align="left">启动新的窗口</td><td align="left">终端输入 <code>tmux neww -n name</code></td></tr><tr><td align="left">根据会话名称启动新的窗口</td><td align="left">终端输入 <code>tmux new -s session-name -n name</code></td></tr><tr><td align="left">退出会话</td><td align="left">终端输入 <code>tmux detach</code></td></tr><tr><td align="left">结束会话</td><td align="left">终端输入 <code>tmux kill-session -t num/name</code></td></tr></tbody></table><blockquote><p>这里退出的意思是退出窗口使其后台运行，结束为 kill</p></blockquote><p>如果在一个会话中可以使用命令模式, 按住前置键 + <code>:</code>, 进入命令模式:</p><table><thead><tr><th align="left">描述</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">新建窗口</td><td align="left">命令模式输入 <code>new-window -n name</code></td></tr><tr><td align="left">新建会话</td><td align="left">命令模式输入 <code>new -s name</code></td></tr><tr><td align="left">切换会话</td><td align="left">命令模式输入 <code>attach-session -t num/name</code></td></tr></tbody></table><p>常用快捷键</p><table><thead><tr><th align="left">描述</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">显示快捷键帮助</td><td align="left"><code>prefix ?</code></td></tr><tr><td align="left">重命名当前会话</td><td align="left"><code>prefix $</code></td></tr><tr><td align="left">切换到上一个会话</td><td align="left"><code>prefix (</code></td></tr><tr><td align="left">切换到下一个会话</td><td align="left"><code>prefix )</code></td></tr><tr><td align="left">退出会话，使其在后台运行</td><td align="left"><code>prefix d</code></td></tr><tr><td align="left">切换窗口</td><td align="left"><code>prefix [0-9]</code></td></tr><tr><td align="left">切换下一个窗口</td><td align="left"><code>prefix p</code></td></tr><tr><td align="left">切换前一个窗口</td><td align="left"><code>prefix n</code></td></tr><tr><td align="left">创建新的窗口</td><td align="left"><code>prefix c</code></td></tr><tr><td align="left">重命名当前窗口</td><td align="left"><code>prefix ,</code></td></tr><tr><td align="left">显示所有窗口的可选择列表</td><td align="left"><code>prefix w</code></td></tr><tr><td align="left">结束窗口</td><td align="left"><code>prefix  &amp;</code></td></tr><tr><td align="left">水平分割面板</td><td align="left"><code>prefix &quot;</code></td></tr><tr><td align="left">垂直分割面板</td><td align="left"><code>prefix %</code></td></tr><tr><td align="left">切换面板</td><td align="left"><code>prefix 方向键</code></td></tr><tr><td align="left">显示面板编号</td><td align="left"><code>prefix q</code></td></tr><tr><td align="left">关闭面板</td><td align="left"><code>prefix x</code></td></tr><tr><td align="left">切换到下一个面板</td><td align="left"><code>prefix o</code></td></tr><tr><td align="left">交换面板位置</td><td align="left"><code>prefix }</code></td></tr></tbody></table><h2 id="复制模式"><a href="#复制模式" class="headerlink" title="复制模式"></a>复制模式</h2><p>添加下面一行到 $HOME/.tmux.conf, 通过 vim 的快捷键实现浏览, 复制等操作;</p><pre><code class="bash">setw -g mode-keys vi</code></pre><table><thead><tr><th align="left">描述</th><th align="left">操作</th></tr></thead><tbody><tr><td align="left">进入复制模式</td><td align="left"><code>prefix [</code></td></tr><tr><td align="left">粘贴选择内容(buffer_0)</td><td align="left"><code>prefix ]</code></td></tr><tr><td align="left">显示 buffer_0 的内容</td><td align="left">命令行模式输入<code>show-buffer</code></td></tr><tr><td align="left">复制整个能见的内容到当前的 buffer</td><td align="left">命令行模式输入<code>capture-buffer</code></td></tr><tr><td align="left">列出所有的 buffer</td><td align="left">命令行模式输入<code>list-buffers</code></td></tr><tr><td align="left">选择用于粘贴的 buffer</td><td align="left">命令行模式输入<code>choose-buffer</code></td></tr><tr><td align="left">将 buffer 的内容复制到文件</td><td align="left">命令行模式输入 <code>save-buffer file.txt</code></td></tr></tbody></table><table><thead><tr><th>vi</th><th>emacs</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>M-m</td><td>跳转到一行开头</td></tr><tr><td>Esc</td><td>C-g</td><td>放弃选择</td></tr><tr><td>k</td><td>Up</td><td>上移</td></tr><tr><td>j</td><td>Down</td><td>下移</td></tr><tr><td>h</td><td>Left</td><td>左移</td></tr><tr><td>l</td><td>Right</td><td>右移</td></tr><tr><td>L</td><td></td><td>最后一行</td></tr><tr><td>M</td><td>M-r</td><td>中间一行</td></tr><tr><td>H</td><td>M-R</td><td>第一行</td></tr><tr><td>$</td><td>C-e</td><td>跳转到行尾</td></tr><tr><td>:</td><td>g</td><td>跳转至某一行</td></tr><tr><td>C-d</td><td>M-Down</td><td>下翻半页</td></tr><tr><td>C-u</td><td>M-Up</td><td>上翻半页</td></tr><tr><td>C-f</td><td>Page down</td><td>下翻一页</td></tr><tr><td>C-b</td><td>Page up</td><td>上翻一页</td></tr><tr><td>w</td><td>M-f</td><td>下一个字符</td></tr><tr><td>b</td><td>M-b</td><td>前一个字符</td></tr><tr><td>q</td><td>Esc</td><td>退出</td></tr><tr><td>?</td><td>C-r</td><td>往上查找</td></tr><tr><td>/</td><td>C-s</td><td>往下查找</td></tr><tr><td>n</td><td>n</td><td>查找下一个</td></tr><tr><td>Space</td><td>C-Space</td><td>进入选择模式</td></tr><tr><td>Enter</td><td>M-w</td><td>确认选择内容, 并退出</td></tr></tbody></table><p>如果想在 iterm2 中使用复制，开启 <code>Applications in terminal may access clipboard</code> 选项。</p><p><img src="/images/tmux_quick_start/tmux_quick_start_01.png" srcset="/img/loading.gif" alt="iterm2"></p><p>然后按住 <code>options</code> 键不放，点击鼠标左键复制。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>自定义配置放在 <code>~/.tmux.conf</code> 中，可以自行 github 搜索相关的配置，来完善自己的配置。</p><p>我目前正在使用的配置:</p><blockquote><p>需要先安装 tmux 插件管理工具 tpm<br>tmux 版本 3.0a</p></blockquote><pre><code class="bash"># 使用 C-a 替换 C-b prefix 按键unbind C-bset-option -g prefix C-abind-key C-a send-prefix# 把窗口的初始索引值从 0 改为 1set -g base-index 1# 关闭窗口时重新对窗口进行排序set-option -g renumber-windows on# 设定前缀键和命令键之间的延时set -sg escape-time 1# prefix R 重载配置文件bind-key R source-file ~/.tmux.conf \; display-message &quot;tmux.conf reloaded.&quot;# 把面板的初始索引值从 0 改为 1setw -g pane-base-index 1# 复制粘贴模式使用 vi 模式setw -g mode-keys vi# 启用鼠标set -g mouse on# 设置默认的终端模式为 256 色模式set-option -g default-terminal screen-256color# 使用 prefix v 和 s 分割面板, 使用 prefix h,j,k,l 在面板间跳转bind-key v split-window -h -c &quot;#{pane_current_path}&quot;bind-key s split-window -v -c &quot;#{pane_current_path}&quot;bind-key h select-pane -Lbind-key j select-pane -Dbind-key k select-pane -Ubind-key l select-pane -R# 复制模式使用 v 开始选择，按 y 结束选择并复制bind-key -T copy-mode-vi &#39;v&#39; send -X begin-selectionbind-key -T copy-mode-vi &#39;y&#39; send -X copy-selection-and-cancel# 引用主题set -g @plugin &#39;jimeh/tmux-themepack&#39;set -g @themepack &#39;powerline/block/gray&#39;# 安装 tpm tmux 管理器插件set -g @plugin &#39;tmux-plugins/tpm&#39;# 保留此行在 tmux 最底部使 tpm 正常工作run -b &#39;~/.tmux/plugins/tpm/tpm&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>terminal-tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
